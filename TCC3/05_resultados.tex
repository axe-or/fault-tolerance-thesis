\chapter{Resultados}
\label{cap:resultados}

\section{Dependabilidade e Performance}
Após repetir o processo de injeção do capítulo anterior para as combinações de técnicas, foi possível coletar os dados representados na \autoref{tab:resSemInj}. O pico de memória da arena para o armazenamento das tarefas é denominado $M_{task}$, o pico da arena de memória adicional é denominado $M_{extra}$. As variáveis $T_{total}$ e $T_{linha}$ representam o tempo total de execução e o tempo médio por linha, respectivamente.

\begin{quadro}[H]
	\centering
	\caption{Resultados sem injeção}
	\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Técnicas} & \textbf{$T_{total}$} & \textbf{$T_{linha}$} & \textbf{$M_{task}$} & \textbf{$M_{extra}$} & \textbf{Detecção} & \textbf{Resultado} \\
		\hline
		N/A & \textsc{1542}ms & 12ms & 2768B & 374B & 0 & OK \\
		CRC32 & 1549ms & 12ms & 2768B & 856B & 0 & OK \\ \hline
		Reexec & 4631ms & 38ms & 2768B & 1074B & 0 & OK \\ \hline
		Reexec + CRC32 & 4635ms & 38ms & 2768B & 1556B & 0 & OK \\ \hline
		TMR & 4644ms & 38ms & 8336B & 1126B & 0 & OK \\ \hline
		TMR + CRC32 & 4651ms & 38ms & 8336B & 1608B & 0 & OK \\ \hline
\end{tabular}
\label{tab:resSemInj}
\end{quadro}

Os resultados neste caso servem para estabelcer uma linha base das latências envolvidas. O método de CRC32 é relativamente rápido, adicionando apenas alguns milisegundos e um pouco menos de 500 bytes para manter o CRC de cada linha da imagem juntamente com buffers temporários para processamento.

As técnicas de reexecução e TMR possuem um grande impacto no tempo de execução de aproxiamente 3.02x, já a técnica de TMR em particular necessita do triplo de memória de tarefas para manter o stack de todas suas sub-tarefas assim como triplo de memória de trabalho para garantir o isolamento entre as sub-tarefas. O tempo de execução entre a Reexecução e TMR não é muito grande, o sistema foi executado sem multiprocessamento simétrico, portanto não foi possível observar as vantagems potenciais causadas pelo uso de paralelismo. O custo das trocas de contexto do kernel e das sincronizações pode ser observado no valor das tarefas TMR serem tipicamente apenas alguns millisegundos mais lentas que as versões de reexecução.


Injetando falhas nos filtros e no output como descrito no \autoref{cap:proj}, foi possível observar o comportamento das técnicas na presença de falhas que não envolvam corrupção de seu stack frame.

\begin{quadro}[H]
	\centering
	\caption{Resultados com Injeção em variáveis fixas}
	\begin{tabular}{|p{0.1\textwidth}|c|c|c|c|c|c|p{0.2\textwidth}|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Técnicas} & \textbf{$T_{total}$} & \textbf{$T_{linha}$} & \textbf{$M_{task}$} & \textbf{$M_{extra}$} & \textbf{Detecção} & \textbf{Resultado} & \textbf{Observação} \\
		\hline
		
		N/A & 1544ms & 12ms & 2768B & 374B & 0 & Corrupção & N/A  \\ \hline
		CRC32 & 1565ms & 12ms & 2768B & 856B & 1 & OK & Corrupção detectada no output apenas \\ \hline
		Reexec & 4634ms & 38ms & 2768B & 1074B & 1 & Corrupção & Mascarou corrupção na linha, mas não no output \\ \hline
		Reexec + CRC32 & 4676ms & 38ms & 2768B & 1556B & 2 & OK & Corrupção mascarada e output recomputado \\ \hline
		TMR & 4647ms & 38ms & 8336B & 1126B & 1 & Corrupção & Mascarou corrupção na linha, mas não no output \\ \hline
		TMR + CRC32 & 4654ms & 38ms & 8336B & 1608B & 2 & OK & Corrupção mascarada e output recomputado \\ \hline
		

	\end{tabular}
	\label{tab:resInjecaoFixa}
\end{quadro}

No \autoref{tab:resInjecaoFixa} é possível observar um padrão, a correção de erro ao final (output) só pode ser concluída no casos em que se possui a presença de um algoritmo de checagem, as técnicas de TMR e Reexecução conseguiram com sucesso mascarar a falha local de uma linha da corrupção com um uma função de consenso majoritário simples, porém uma vez que o valor já tenha sido calculado não é mais possível validar sua integridade.


% TODO botar isso num apendice?
\subsection{Impacto no Output}

Nem todas as execuções geram o output válido, e algumas geraram o output correto, esta seção serve para cunho de exemplo, demonstrando alguns dos efeitos observados de corrupções silenciosas na imagem resultado.

% TODO: Lena OG e Lena Filtrada (baseline)
% TODO: Lena com kernel corrompido
% TODO: Lena com tamanho corrompido (pular pedaço da imagem)
% TODO: Lena interrompida, filtro parcial

\section{Verificação}

Após a análise das técnicas, é possível verificar os requisitos funcionais na \autoref{tab:verirf} e não-funcionais no \autoref{tab:verirnf}.

\begin{quadro}[H]
    \centering
    \caption{Requisitos funcionais}
    \begin{tabular}{|p{0.125\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
        \hline
        \rowcolor[HTML]{C0C0C0}
        \textbf{Requisito} & \textbf{Descrição} & \textbf{Validação} \\
        \hline

        \textbf{RF01} & Implementação de todos os algoritmos descritos na \autoref{subsec:algoritmos} & TODO \\
        \hline

        \textbf{RF02} & Configuração do mecanismo de tolerância, prioridade e prazo de execução da tarefa & TODO\\
        \hline

        \textbf{RF03} & Cumprimento do prazo estipulado no momento de criação da tarefa caso não exista presença de falhas & Validado com os testes sem injeção de falha \\
        \hline

        \textbf{RF04} & Dependabilidade superior à versão do sistema sem técnicas & O sistema foi capaz de mascarar algumas falhas e detectar outras. Portanto possui uma dependabilidade superior \\
        \hline

        \textbf{RF05} & Monitoramento do número de falhas detectadas e violações de prazos & Implementado em \texttt{DeadlineWatcher} em conjunto com o IWDG. Foi capaz de detectar violações \\
        \hline
    \end{tabular}
    \label{tab:verirf}
\end{quadro}

Os requisitos não funcionais também foram analisados conforme o \autoref{tab:verirnf}.

\begin{quadro}[H]
    \centering
    \caption{Validação dos Requisitos não funcionais}
    \begin{tabular}{|p{0.125\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
        \hline
        \rowcolor[HTML]{C0C0C0}
        \textbf{Requisito} & \textbf{Descrição} & \textbf{Validação} \\
        \hline

        \textbf{RNF01} & O consumo de memória deve ser pré determinado em tempo de compilação ou na inicialização do sistema & O pico de memória é estável e determinado no startup da aplicação \\
        \hline

        \textbf{RNF02} & A interface deve ser construida sobre o escalonador preemptivo do FreeRTOS & Os mecanismos de tarefa são implementados sobre o escalonador \\
        \hline

        \textbf{RNF03} & Deve ser compatível com arquitetura ARMv7M ou ARMv8M & O projeto compila e executa na arquitetura \\
        \hline

        \textbf{RNF04} & Implementação realizada em C++ (versão 20 ou acima) & O projeto compila na versão C++20 com GCC e Clang\\
        \hline

        \textbf{RNF05} & Código Fonte disponível sob licença permissíva & Validado parcialmente. O módulo de USB\_DEVICE não é compatível com uma licença BSD2 porém não é essencial apra a demonstração das técnicas. O resto do código cumpre este requisito. \\
        \hline
    \end{tabular}
    \label{tab:verirnf}
\end{quadro}

% TODO: Link do github com historico limpo

