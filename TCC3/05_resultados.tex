\chapter{Resultados}
\label{cap:resultados}

\section{Execução}
\label{sec:execucao}

O projeto é compilado com o compilador GCC da toolchain oficial para embarcados da ARM (\texttt{arm-eabi-none}). O script \texttt{build.lua} provê uma interface CLI simples para compilar o projeto para a plataforma escolhida.

\subsection{Injeção de falhas}
Após compilar o projeto em um arquivo ELF com informação de debug é encontrar quais os símbolos seus endereços para relizar a injeção. Para a fase de injeção em locais conhecidos, os símbolos escolhidos foram:

\begin{itemize}
    \item \texttt{kernel}: Filtro (kernel) do contexto de convolução usado
  
    \item \texttt{output\_row}s: Linha(s) utilizadas como espaço de resultado para a convolução

    \item \texttt{output}: Resultado final
\end{itemize}

Para a fase de injeção com offsets do stack, foram sorteados uma variável local da função e um tamanho entre 4 a 32 bytes (1 a 4 palavras).

\subsection{Demonstração do processo de Injeção}

Com o microcontrolador conectado via ST-Link e com VirtualCOM por USB é inicializada uma sessão de debugging, o primeiro passo é inicializar a sessão com o breakpoint padrão na função \texttt{main} (\autoref{fig:injStartDebugger}) que é definida pelo código de plataforma da HAL fornecida pelo fabricante do microcontrolador. É inserido um breakpoint na função \texttt{entrypoint} que o ponto de entrada real da aplicação que ocorre após o setup de periféricos e do RTOS.

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \caption{Inicializar sessão de debugging no ST-Link}
    \includegraphics[width=1.0\textwidth]{assets/inj_start_debugger.png} \\
    \captionsetup{justification=raggedright}
    \caption*{Fonte: Elaborada pelo autor}
    \label{fig:injStartDebugger}
\end{figure}

O programa é resumido Até alcançar o breakpoint, neste momento, é recomendado iniciar a conexão VirtualCOM para observar o sistema, aqui foi usado o \texttt{microCOM} pelo terminar do VSCode como demonstrado na \autoref{fig:injConnectCOM}.

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \caption{Conectar via VirtualCOM}
    \includegraphics[width=1.0\textwidth]{assets/inj_connect_com.png} \\
    \captionsetup{justification=raggedright}
    \caption*{Fonte: Elaborada pelo autor}
    \label{fig:injConnectCOM}
\end{figure}

É selecionado um local para a injeção, neste caso será realizado uma injeção fixa nas linhas de output no exemplo com reexecução. Recomenda-se usar a funcionalidade de breakpoints condicionais para avançar para uma iteração desajada, na \autoref{fig:injCondBreakpoint} foi escolhido uma iteração específica.

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \caption{Posicionar Breakpoint}
    \includegraphics[width=1.0\textwidth]{assets/inj_cond_breakpoint.png} \\
    \captionsetup{justification=raggedright}
    \caption*{Fonte: Elaborada pelo autor}
    \label{fig:injCondBreakpoint}
\end{figure}

Para realizar um upset, é selecionado o endereço do local escolhido e aplicado pelo console do debugger. Neste caso foi realizado um XOR com uma máscara de bits aleatória. A \autoref{fig:injCauseUpset} demonstra este processo.

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \caption{Causar upset}
    \includegraphics[width=1.0\textwidth]{assets/inj_cause_upset.png} \\
    \captionsetup{justification=raggedright}
    \caption*{Fonte: Elaborada pelo autor}
    \label{fig:injCauseUpset}
\end{figure}

Após feitas as injeções desejadas, o programa é resumido e seu resultado inspecionado.
% TODO continue


\section{Dependabilidade e Performance}

Após repetir o processo de injeção da \autoref{sec:execucao} para as combinações de técnicas, foi possível coletar os dados representados na \autoref{tab:resSemInj}. O pico de memória da arena para o armazenamento das tarefas é denominado $M_{task}$, o pico da arena de memória adicional é denominado $M_{extra}$. As variáveis $T_{total}$ e $T_{linha}$ representam o tempo total de execução e o tempo médio por linha, respectivamente.

\begin{quadro}[H]
	\centering
	\caption{Resultados sem injeção}
	\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Técnicas} & \textbf{$T_{total}$} & \textbf{$T_{linha}$} & \textbf{$M_{task}$} & \textbf{$M_{extra}$} & \textbf{Detecção} & \textbf{Resultado} \\
		\hline
		N/A & \textsc{1542}ms & 12ms & 2768B & 374B & 0 & OK \\
		CRC32 & 1549ms & 12ms & 2768B & 856B & 0 & OK \\ \hline
		Reexec & 4631ms & 38ms & 2768B & 1074B & 0 & OK \\ \hline
		Reexec + CRC32 & 4635ms & 38ms & 2768B & 1556B & 0 & OK \\ \hline
		TMR & 4644ms & 38ms & 8336B & 1126B & 0 & OK \\ \hline
		TMR + CRC32 & 4651ms & 38ms & 8336B & 1608B & 0 & OK \\ \hline
\end{tabular}
\label{tab:resSemInj}
\end{quadro}

Os resultados neste caso servem para estabelcer uma linha base das latências envolvidas. O método de CRC32 é relativamente rápido, adicionando apenas alguns milisegundos e um pouco menos de 500 bytes para manter o CRC de cada linha da imagem juntamente com buffers temporários para processamento.

As técnicas de reexecução e TMR possuem um grande impacto no tempo de execução de aproxiamente 3.02x, já a técnica de TMR em particular necessita do triplo de memória de tarefas para manter o stack de todas suas sub-tarefas assim como triplo de memória de trabalho para garantir o isolamento entre as sub-tarefas. O tempo de execução entre a Reexecução e TMR não é muito grande, o sistema foi executado sem multiprocessamento simétrico, portanto não foi possível observar as vantagems potenciais causadas pelo uso de paralelismo. O custo das trocas de contexto do kernel e das sincronizações pode ser observado no valor das tarefas TMR serem tipicamente apenas alguns millisegundos mais lentas que as versões de reexecução.


Injetando falhas nos filtros e no output como descrito no \autoref{cap:proj}, foi possível observar o comportamento das técnicas na presença de falhas que não envolvam corrupção de seu stack frame.

\begin{quadro}[H]
	\centering
	\caption{Resultados com Injeção em variáveis fixas}
	\begin{tabular}{|p{0.1\textwidth}|c|c|c|c|c|c|p{0.2\textwidth}|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Técnicas} & \textbf{$T_{total}$} & \textbf{$T_{linha}$} & \textbf{$M_{task}$} & \textbf{$M_{extra}$} & \textbf{Detecção} & \textbf{Resultado} & \textbf{Observação} \\
		\hline
		
		N/A & 1544ms & 12ms & 2768B & 374B & 0 & Corrupção & N/A  \\ \hline
		CRC32 & 1565ms & 12ms & 2768B & 856B & 1 & OK & Corrupção detectada no output apenas \\ \hline
		Reexec & 4634ms & 38ms & 2768B & 1074B & 1 & Corrupção & Mascarou corrupção na linha, mas não no output \\ \hline
		Reexec + CRC32 & 4676ms & 38ms & 2768B & 1556B & 2 & OK & Corrupção mascarada e output recomputado \\ \hline
		TMR & 4647ms & 38ms & 8336B & 1126B & 1 & Corrupção & Mascarou corrupção na linha, mas não no output \\ \hline
		TMR + CRC32 & 4654ms & 38ms & 8336B & 1608B & 2 & OK & Corrupção mascarada e output recomputado \\ \hline
		

	\end{tabular}
	\label{tab:resInjecaoFixa}
\end{quadro}

No \autoref{tab:resInjecaoFixa} é possível observar um padrão, a correção de erro ao final (output) só pode ser concluída no casos em que se possui a presença de um algoritmo de checagem, as técnicas de TMR e Reexecução conseguiram com sucesso mascarar a falha local de uma linha da corrupção com um uma função de consenso majoritário simples, porém uma vez que o valor já tenha sido calculado não é mais possível validar sua integridade. 


% TODO QUADRO COM CORRUPCAO DE STACK FRAME




% TODO botar isso num apendice?
\subsection{Impacto no Output}

Foram selecionadas execuções que resultam em um output que possa ser visualizado para melhor demonstrar

% TODO: Lena OG e Lena Filtrada (baseline)
% TODO: Lena com kernel corrompido
% TODO: Lena com tamanho corrompido (pular pedaço da imagem)
% TODO: Lena interrompida, filtro parcial
% TODO: Gato com upset sutil (2 pixel mudado)


% TODO: Link do github com historico LIMPO!

\section{Verificação}

Durante do desenvolvimento e coleta dos dados, foi possível verificar os requisitos funcionais descritos no \autoref{tab:verirf}.

\begin{quadro}[H]
	\centering
	\caption{Requisitos funcionais}
	\begin{tabular}{|p{0.125\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Requisito} & \textbf{Descrição} & \textbf{Validação} \\
		\hline
		
		\textbf{RF01} & Implementação de todos os algoritmos descritos na \autoref{subsec:algoritmos} & Os algoritmos foram implementados e utilizados para os experimentos no \autoref{cap:resultados} \\
		\hline
		
		\textbf{RF02} & Configuração do mecanismo de tolerância, prioridade e prazo de execução da tarefa & A configuração do mecanismo é feita de forma imperativa, já o prazo, prioridade e tamanho da pilha são feitos declarativamente no momento de instanciação da tarefa \\
		\hline
		
		\textbf{RF03} & Cumprimento do prazo estipulado no momento de criação da tarefa caso não exista presença de falhas & Validado com os testes sem injeção de falha \\
		\hline
		
		\textbf{RF04} & Dependabilidade superior à versão do sistema sem técnicas & O sistema foi capaz de mascarar algumas falhas e detectar outras. Portanto possui uma dependabilidade superior \\
		\hline
		
		\textbf{RF05} & Monitoramento do número de falhas detectadas e violações de prazos & Implementado em \texttt{DeadlineWatcher} em conjunto com o IWDG. Foi capaz de detectar violações \\
		\hline
	\end{tabular}
	\label{tab:verirf}
\end{quadro}

Os requisitos não funcionais também foram analisados conforme o \autoref{tab:verirnf}.

\begin{quadro}[H]
	\centering
	\caption{Validação dos Requisitos não funcionais}
	\begin{tabular}{|p{0.125\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
		\hline
		\rowcolor[HTML]{C0C0C0}
		\textbf{Requisito} & \textbf{Descrição} & \textbf{Validação} \\
		\hline
		
		\textbf{RNF01} & O consumo de memória deve ser pré determinado em tempo de compilação ou na inicialização do sistema & O pico de memória é estável e determinado no startup da aplicação \\
		\hline
		
		\textbf{RNF02} & A interface deve ser construida sobre o escalonador preemptivo do FreeRTOS & Os mecanismos de tarefa são implementados sobre o escalonador \\
		\hline
		
		\textbf{RNF03} & Deve ser compatível com arquitetura ARMv7M ou ARMv8M & O projeto compila e executa na arquitetura \\
		\hline
		
		\textbf{RNF04} & Implementação realizada em C++ (versão 20 ou acima) & O projeto compila na versão C++20 com GCC e Clang\\
		\hline
		
		\textbf{RNF05} & Código Fonte disponível sob licença permissíva & Validado parcialmente. O módulo de USB\_DEVICE não é compatível com uma licença BSD2 porém não é essencial apra a demonstração das técnicas. O resto do código cumpre este requisito. \\
		\hline
	\end{tabular}
	\label{tab:verirnf}
\end{quadro}

\subsection{Discussão dos Resultados}

A aplicação das técnicas resultou em um impacto positivo na dependabilidade do sistema, em particular técnicas de execução (TMR e Reexecução) em combinação com a checagem por CRC32 demonstraram a melhor dependabilidade.

O custo das técnicas de execução é significativo, triplicando o tempo computacional no caso de um sistema sem multi processamento simétrico e adicionando um overhead de memória alto (mais de 3x) no caso da aplicação de TMR. Para o sistema apresentado, a reexecução em combinação com o CRC32 possui bons resultados dado seu consumo menor de memória quando comparado à técnica de TMR. 

Durante injeções aleatórias no stack frame, a redundância de estado adicional do TMR contribuiu para evitar um erro fatal, indicando que talvez outros padrões de falha sejam melhor capturados e mascarados pela técnica de TMR, justificando seu custo adicional de memória. É também interessante que trabalhos futuros avaliem a técnica de TMR no contexto de multiprocessamento simétrico para analisar o potencial impacto positivo da execução paralela, dado que a técnica de TMR possui uma grande vantagem ao prover maior isolamento de estado mutável.

A validação de deadline não foi ativa com frequência durante os testes, mesmo nos casos de injeções aleatórias um erro fatal via assert foi capaz de interromper a execução primeiro. Isso não significa que os testes de deadline não possuiram nenhum impacto positivo, pois foi possível detectar um deadlock de sincronização durante o desenvolvimento mais cedo graças a um disparo prematuro, porém os resultados apresentados não foram capazes de causar uma mudança significativa no tempo de execução que ativasse o monitor. Injeções de falhas que alterem mais o fluxo de controle, ou a aplicação de um programa de teste com características temporais mais sensíveis à upsets de memória talvez seja capaz de gerar mais oportunidades para a contribuição desta técnica.


