#include "strings.hpp"


#define MASKX 0x3f /* 0011_1111 */
#define MASK2 0x1f /* 0001_1111 */
#define MASK3 0x0f /* 0000_1111 */
#define MASK4 0x07 /* 0000_0111 */

#define CONT_LO 0x80
#define CONT_HI 0xbf

struct  UTF8AcceptRange { u8 lo, hi; };

static const struct UTF8AcceptRange utf8_accept_ranges[5] = {
	{0x80, 0xbf},
	{0xa0, 0xbf},
	{0x80, 0x9f},
	{0x90, 0xbf},
	{0x80, 0x8f},
};

// Check bottom of file to see how this LUT was generated
static const u8 utf8_accept_sizes[256] = {
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
	0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,
	0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,
	0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,
	0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,
	0xf1,0xf1,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
	0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
	0x13,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x23,0x03,0x03,
	0x34,0x04,0x04,0x04,0x44,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,
};

RuneDecoded str_decode_rune(byte const* buf, usize buflen){
	RuneDecoded result = {};
	const RuneDecoded error = { .codepoint = RUNE_ERROR, .size = 1 };

	if(buflen < 1){
		return result;
	}

	byte b0 = buf[0];
	byte x = utf8_accept_sizes[b0];

	/* ASCII or invalid */
	if(x >= 0xf0){
		u32 mask = ((rune)(x) << 31) >> 31; /* Either all 0's or all 1's to avoid branching */
		result.codepoint = ((rune)(b0) & ~mask) | (RUNE_ERROR & mask);
		result.size = 1;
		return result;
	}

	byte sz = x & 7;
	struct UTF8AcceptRange accept = utf8_accept_ranges[x >> 4];

	if(buflen < sz){
		return error;
	}

	byte b1 = buf[1];
	if(b1 < accept.lo || accept.hi < b1){
		return error;
	}
	if(sz == 2){
		result.codepoint = ((rune)(b0 & MASK2) << 6) | ((rune)(b1 & MASKX));
		result.size = 2;
		return result;
	}

	byte b2 = buf[2];
	if(b2 < CONT_LO || CONT_HI < b2){
		return error;
	}

	if(sz == 3){
		result.codepoint = ((rune)(b0 & MASK3) << 12) | ((rune)(b1 & MASKX) << 6) | (rune)(b2 & MASKX);
		result.size = 3;
		return result;
	}

	byte b3 = buf[3];
	if(b3 < CONT_LO || CONT_HI < b3){
		return error;
	}

	result.codepoint = ((rune)(b0 & MASK4) << 18) | ((rune)(b1 & MASKX) << 12) | ((rune)(b2 & MASKX) << 6) | (rune)(b3 & MASKX);
	result.size = 4;
	return result;
}

RuneEncoded str_encode_rune(rune r){
	const u8 mask = 0x3f;
	RuneEncoded result = {};

	if(r <= 0x7f){ // 1-wide (ASCII)
		return (RuneEncoded){ .bytes = {(u8)r}, .size = 1 };
	}

	if(r <= 0x7ff){ // 2-wide
		result.bytes[0] = 0xc0 | (u8)(r >> 6);
		result.bytes[1] = 0x80 | (u8(r) & mask);
		result.size = 2;
		return result;
	}

	// Surrogate or invalid -> Encode the error rune
	if((r > 0x10ffff) || ((0xd800 <= r) && (r <= 0xdfff))){
		r = 0xfffd;
	}

	if(r <= 0xffff){ // 3-wide
		result.bytes[0] = 0xe0 | u8(r >> 12);
		result.bytes[1] = 0x80 | (u8(r >> 6) & mask);
		result.bytes[2] = 0x80 | (u8(r)      & mask);
		result.size = 3;
		return result;
	}
	else { // 4-wide
		result.bytes[0] = 0xf0 | u8(r >> 18);
		result.bytes[1] = 0x80 | (u8(r >> 12) & mask);
		result.bytes[2] = 0x80 | (u8(r >> 6)  & mask);
		result.bytes[3] = 0x80 | (u8(r)       & mask);
		result.size = 4;
		return result;
	}
}

/*
	Accept sizes lookup table was generated with this python script:

	# First nibble is which accept_range shall be used, the second one indicates size
	# for multibyte sequences. Single size sequences are treated as a special case where
	# the last bit indicates if the codepoint will be decoded as an error rune or not.
	# Keys are the ranges (inclusive)
	accept_sizes = {
		(0x00, 0x7f): 0xf0, # ASCII,    size 1
		(0x80, 0xc1): 0xf1, # invalid,  size 1
		(0xc2, 0xdf): 0x02, # accept 1, size 2
		(0xe0, 0xe0): 0x13, # accept 1, size 3
		(0xe1, 0xec): 0x03, # accept 0, size 3
		(0xed, 0xed): 0x23, # accept 2, size 3
		(0xee, 0xef): 0x03, # accept 0, size 3
		(0xf0, 0xf0): 0x34, # accept 3, size 4
		(0xf1, 0xf3): 0x04, # accept 0, size 4
		(0xf4, 0xf4): 0x44, # accept 4, size 4
		(0xf5, 0xff): 0xf1, # ASCII,    size 1
	}

	out = []
	for rg, val in accept_sizes.items():
		for b in range(rg[0], rg[1] + 1):
			out.append(f'0x{val:02x}')
	print(','.join(out))

*/

#undef MASKX
#undef MASK2
#undef MASK3
#undef MASK4
#undef CONT_LO
#undef CONT_HI
