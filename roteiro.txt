
# intro

sistemas embarcados estão presentes em várias coisas:
 - equipamento medico
 - infraestrutura
 - aplicações críticas
 - eletrodomesticos

muitos vem equipados com um sistema operacional de tempo real

esses sistemas idealmente precisam funcionar o tempo todo mesmo em condicoes
adversas como radiação, harmonicas, flutuções elétricas.

para resolver esse problema existem técnicas de tolerancia a falhas

o impacto das tecnicas em termos de performance não são muito claros, e pode
ser inconveniente implemetnar as tecnicas

# intro

a solucao entao eh implemetnar tecnicas proximas ao escalonador do RTOS e
analisar o impacto d eperformance causado e fornecer uma interface pro uso das
tecnicas

<< Falar objetivos >>

# def

<< As-is >>

# def

<< As-is >>

# embed sys

como dito antes são encontrados em diversas aplicacoes principais
caracteristicas sao um proposito especializado limitação/pré-determinação de
recursos disponiveis e o seu criterio temporal, sendo soft ou hard real-time

sistemas soft real time precisam no mínimo fazer tarefas de alta prioridade
executarem primeiro e tentarem cumprir seu prazo de execucao. em Sistemas hard
real time, uma resposta tardia por sí só já consititui um erro

# rtos

possibilitam a execucao de multiplas tarefas, geralmetne possuem poucas
features e sustentar o critério hard real time

# scheduler

organiza e troca entre tarefas, componente essencial para a execucao do sistema

# falhas

<< As-is >>

# deteccao

o crc é um valor de checagem que pode ser verificado pelo destinatario e
remetente de um payload, é uma técncia baseada em um polinomio gerador

asserts são checagens simples que verificam uma invariante do sistema,
disparando uma falha caso contrario

# hearbeat

o hearbeat signal, tambem chamado de watchdog checking, consistente em disparar
um sinal periodico e verificar se uma taarefa responde dentro do prazo

na esquerda tem um exemplo de um check ok, e na direita um que indica uma falha

# tmr

redundancia pode ser inserido em diversos contextos, no caso da execução de
tarefas pode ser realizado uma execucao concorrente com um consenso ao final,
isso nem sempre é possivel caso tenha muito estado compartilhado entre tasks

# reexec

replicacao temporal, ou reexecucao, consiste em reexecutar uma tarefa em caso
de falha (como um mecanismo de tratamento) ou reexecutar incondicionalmente
como mecanismo de tolerancia. é possível reservar a deadline de N execucoes
para criar condições de transparencia independente do modelo escolhido

# sched ft

aqui um grafo que representa um programa simples com 3 processos e uma
mensagem. o P1 executa, seguido pelo P2 que envia uma mensagem para P3. P1 e P2
necessitam de execucao sequencial, mas p3 pode ser um processo assíncrono

# sched ft

aqui o mesmo grafo demonstrando a execucao com tolerancia à uma falha
transiente, é possível observer um aumento grande na complexidade, o que torna
o programa menos previsível

# sched ft

ao inserir uma condição de transparencia em P2, tudo o que está abaixo dele
pode assumir "como se" nenhuma falha ocorresse, isso tipicamente necessita
garantir uma deadline maior para P2

introduzir condicoes de transparencia pode controlar a complexidade do grafo de
execucao

# injecao de falhas

<< As-is >>

# comparacao

no primeiro trabalho foi feito um teste com injeção física para criar um perfil
de falhas, deposi foi implementado as técnicas que aqui são redundancia e
não-uso de registradores, foi feita uma injeção lógica em software usando o
perfil e foi possível detectar mais da metade das falhas. tambem foi observado
que a memória foi duas ordens de magnitude mais sensível do que os
registradores

no segundo trabalho foi criada uma interface de tolerancia e deteccao para o
sistema operacional BOSS, foi entao realizado um teste com resultados
favoraveis, conseguindo o grau de confiabilidade desejado utilizando um PSP
(par de processadores) ao invez de TMR

no terceiro trabalho é feita uma análise de fluxo de programa para detectar
jumps corruptos, esse é o trabalho que mais difere nas técnicas apresentadas, é
usado injeção lógica em hardware e é observado que o método é 50% superior à
uma checagem de correlacao baseada em assinturas


